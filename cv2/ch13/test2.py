# encoding:utf-8
'''
图像模糊-平均
是由一个归一化卷积框完成的，它只是用卷积框覆盖区域所有像素的平均值来代替
中心元素， 可以使用函数cv2.blur() 和 cv2.boxFilter()来完成这个任务
'''

import cv2
import numpy as np
import matplotlib.pyplot as plt

img = cv2.imread('../data/opencv_logo.png')
# 图像卷积
# blur = cv2.blur(img, (5, 5))
'''
现在讲卷积核换成高斯核，原来每个方框的值是相等的，现在每个方框的值是符合高斯分布的，
方框中心的值最大，其余方框根据离中心元素的距离构成一个高斯小山包，
原来的求平均值现在变成求加权平均数
'''

# 0是指根据窗口的大小（5,5） 来计算高斯函数的标准差
# blur = cv2.GaussianBlur(img, (5, 5), 0)
'''
 中值滤波器顾名思义就是用卷积框对应像素的中值来替代中心
 像素的值，这个滤波器经常用来去除椒盐噪声
 前面的滤波器使用计算得到的一个新值来取代中心像素的值，
 而中值滤波使用中心像素周围也可以用它本身的值来取代他，
 他能有效的去除噪声，卷积核的大小也应该是一个奇数
'''
# blur = cv2.medianBlur(img, 5)
'''
函数cv2.bilateralFilter()能在保持边界清晰的情况下有效的去噪
但是这种操作与其他的滤波相比会比较慢
高斯滤波器是求中心点与邻近区域像素的高斯加权平均值
这种滤波器只考虑像素之间的空间关系
而不会考虑像素之间的关系，像素的相似度
所以这种方法不会考虑一个像素是否位于边界
因此边界也会被模糊掉，这不是我们想要的

双边滤波同时使用空间高斯滤波和灰度值相似性高斯权
空间高斯滤波函数确保只有邻近区域的像素对中心点有影响
灰度值相似性高斯函数确保只有与中心像素灰度值相近的才会用来做模糊运算
所以这种方法会确保边界不会被模糊掉
因为边界的灰度值变化比较大
'''
# 9是区域直径， 75分别是空间高斯函数标准差和灰度值相似性高斯函数标准差
blur = cv2.bilateralFilter(img, 9, 75, 75)
plt.subplot(121), plt.imshow(img), plt.title('Original')
plt.xticks([]), plt.yticks([])
plt.subplot(122), plt.imshow(blur), plt.title('Blurred')
plt.xticks([]), plt.yticks([])
plt.show()